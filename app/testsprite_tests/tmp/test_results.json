[
  {
    "projectId": "eb0756a5-62c6-4448-a02d-a326d56f1949",
    "testId": "b70b0951-287c-48e4-b345-690e7efe49ec",
    "userId": "a4b8d4c8-2041-70db-c1a1-eccd7d9aa439",
    "title": "TC001-auth login functionality",
    "description": "Verify that the /auth/login endpoint allows users to log in with valid credentials and returns an authentication token.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_auth_login_functionality():\n    login_url = f\"{BASE_URL}/auth/login\"\n    \n    # Assuming test credentials for public/auth/admin roles with Alert and Case Verification access\n    # These credentials should be adjusted as per actual test setup\n    test_credentials = {\n        \"email\": \"admin@example.com\",\n        \"password\": \"StrongPassword123!\"\n    }\n    \n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    \n    try:\n        response = requests.post(login_url, json=test_credentials, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to {login_url} failed: {e}\"\n    \n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    \n    try:\n        response_data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n    \n    assert \"token\" in response_data, \"Response JSON does not contain 'token'\"\n    token = response_data[\"token\"]\n    assert isinstance(token, str) and len(token) > 0, \"'token' should be a non-empty string\"\n\ntest_auth_login_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 36, in <module>\n  File \"<string>\", line 25, in test_auth_login_functionality\nAssertionError: Expected status code 200, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-30T01:25:23.067Z",
    "modified": "2026-01-30T01:26:02.474Z"
  },
  {
    "projectId": "eb0756a5-62c6-4448-a02d-a326d56f1949",
    "testId": "99560b70-e42f-4894-8297-5c4ce1a6053e",
    "userId": "a4b8d4c8-2041-70db-c1a1-eccd7d9aa439",
    "title": "TC002-auth register functionality",
    "description": "Verify that the /auth/register endpoint allows new users to register with valid data and creates a user account.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nREGISTER_ENDPOINT = f\"{BASE_URL}/auth/register\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/auth/login\"\n\ndef test_auth_register_functionality():\n    # Generate unique user data for registration\n    unique_suffix = str(uuid.uuid4())\n    register_data = {\n        \"name\": f\"Test User {unique_suffix}\",\n        \"email\": f\"testuser_{unique_suffix}@example.com\",\n        \"password\": \"StrongPassword!123\",\n        \"password_confirmation\": \"StrongPassword!123\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        # 1. Register new user\n        response = requests.post(\n            REGISTER_ENDPOINT,\n            json=register_data,\n            headers=headers,\n            timeout=30\n        )\n        assert response.status_code == 201, f\"Expected 201 Created but got {response.status_code}\"\n        response_json = response.json()\n        assert \"user\" in response_json, \"'user' field not found in response\"\n        user = response_json[\"user\"]\n        assert user.get(\"email\") == register_data[\"email\"], \"Registered user's email does not match request email\"\n\n        # 2. Verify that the user can log in with the registered credentials\n        login_data = {\n            \"email\": register_data[\"email\"],\n            \"password\": register_data[\"password\"]\n        }\n        login_response = requests.post(\n            LOGIN_ENDPOINT,\n            json=login_data,\n            headers=headers,\n            timeout=30\n        )\n        assert login_response.status_code == 200, f\"Expected 200 OK for login but got {login_response.status_code}\"\n        login_json = login_response.json()\n        assert \"token\" in login_json or \"access_token\" in login_json, \"Authentication token not found in login response\"\n\n        # 3. Validate Alert and Case Verification public endpoints (no auth required)\n        alert_public_response = requests.get(f\"{BASE_URL}/public/alerts\", timeout=30)\n        assert alert_public_response.status_code == 200, f\"Expected 200 OK for /public/alerts but got {alert_public_response.status_code}\"\n        alerts_json = alert_public_response.json()\n        assert isinstance(alerts_json, (list, dict)), \"Expected list or dict as alerts response\"\n\n        # For Case Verification, since no code given, just test that endpoint is accessible\n        verify_code = \"dummycode\"\n        verify_response = requests.get(f\"{BASE_URL}/public/verify/{verify_code}\", timeout=30)\n        # Response can be 200 or 404 depending on code existence, just check accessibility\n        assert verify_response.status_code in (200, 404), f\"Expected 200 or 404 for /public/verify/{{code}} but got {verify_response.status_code}\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_auth_register_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 65, in <module>\n  File \"<string>\", line 29, in test_auth_register_functionality\nAssertionError: Expected 201 Created but got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-30T01:25:23.073Z",
    "modified": "2026-01-30T01:26:00.990Z"
  },
  {
    "projectId": "eb0756a5-62c6-4448-a02d-a326d56f1949",
    "testId": "b102c7b4-1de8-4e7e-9336-6df7811b3735",
    "userId": "a4b8d4c8-2041-70db-c1a1-eccd7d9aa439",
    "title": "TC003-auth logout functionality",
    "description": "Verify that the /auth/logout endpoint logs out an authenticated user and invalidates the authentication token.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_auth_logout_functionality():\n    register_url = f\"{BASE_URL}/auth/register\"\n    login_url = f\"{BASE_URL}/auth/login\"\n    logout_url = f\"{BASE_URL}/auth/logout\"\n    me_url = f\"{BASE_URL}/auth/me\"\n\n    # Test user data for registration\n    user_data = {\n        \"name\": \"Test User\",\n        \"email\": \"testuser_logout@example.com\",\n        \"password\": \"TestPassword123!\",\n        \"password_confirmation\": \"TestPassword123!\"\n    }\n\n    session = requests.Session()\n\n    try:\n        # Register new user\n        reg_resp = session.post(register_url, json=user_data, timeout=TIMEOUT)\n        assert reg_resp.status_code in (200,201), f\"Registration failed: {reg_resp.text}\"\n\n        # Login to get auth token\n        login_payload = {\n            \"email\": user_data[\"email\"],\n            \"password\": user_data[\"password\"]\n        }\n        login_resp = session.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n\n        login_json = login_resp.json()\n        # Expect token in login response, this may be in headers or json, guess json: token or access_token\n        token = None\n        if \"token\" in login_json:\n            token = login_json[\"token\"]\n        elif \"access_token\" in login_json:\n            token = login_json[\"access_token\"]\n        assert token, \"Auth token not found in login response\"\n\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Verify that /auth/me works before logout\n        me_resp = session.get(me_url, headers=headers, timeout=TIMEOUT)\n        assert me_resp.status_code == 200, f\"/auth/me failed before logout: {me_resp.text}\"\n        me_json = me_resp.json()\n        assert \"email\" in me_json and me_json[\"email\"] == user_data[\"email\"], \"User email mismatch before logout\"\n\n        # Call logout endpoint\n        logout_resp = session.post(logout_url, headers=headers, timeout=TIMEOUT)\n        assert logout_resp.status_code == 200, f\"Logout failed: {logout_resp.text}\"\n\n        # After logout, token should be invalidated\n        me_post_logout_resp = session.get(me_url, headers=headers, timeout=TIMEOUT)\n        # Expect unauthorized or token invalid response\n        assert me_post_logout_resp.status_code in (401, 403), \"Token still valid after logout\"\n\n        # Also test that logout twice or logout without token should fail gracefully\n        logout_again_resp = session.post(logout_url, headers=headers, timeout=TIMEOUT)\n        # Either 401 unauthorized or 200 (idempotent logout)\n        assert logout_again_resp.status_code in (200, 401, 403), \"Unexpected response when logging out again\"\n\n    finally:\n        # Cleanup user if API supported user deletion (not specified in PRD, so skipping)\n        pass\n\ntest_auth_logout_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 70, in <module>\n  File \"<string>\", line 25, in test_auth_logout_functionality\nAssertionError: Registration failed: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>Not Found</title>\n\n        <style>\n            /*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}a{background-color:transparent}code{font-family:monospace,monospace;font-size:1em}[hidden]{display:none}html{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5}*,:after,:before{box-sizing:border-box;border:0 solid #e2e8f0}a{color:inherit;text-decoration:inherit}code{font-family:Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}svg,video{display:block;vertical-align:middle}video{max-width:100%;height:auto}.bg-white{--bg-opacity:1;background-color:#fff;background-color:rgba(255,255,255,var(--bg-opacity))}.bg-gray-100{--bg-opacity:1;background-color:#f7fafc;background-color:rgba(247,250,252,var(--bg-opacity))}.border-gray-200{--border-opacity:1;border-color:#edf2f7;border-color:rgba(237,242,247,var(--border-opacity))}.border-gray-400{--border-opacity:1;border-color:#cbd5e0;border-color:rgba(203,213,224,var(--border-opacity))}.border-t{border-top-width:1px}.border-r{border-right-width:1px}.flex{display:flex}.grid{display:grid}.hidden{display:none}.items-center{align-items:center}.justify-center{justify-content:center}.font-semibold{font-weight:600}.h-5{height:1.25rem}.h-8{height:2rem}.h-16{height:4rem}.text-sm{font-size:.875rem}.text-lg{font-size:1.125rem}.leading-7{line-height:1.75rem}.mx-auto{margin-left:auto;margin-right:auto}.ml-1{margin-left:.25rem}.mt-2{margin-top:.5rem}.mr-2{margin-right:.5rem}.ml-2{margin-left:.5rem}.mt-4{margin-top:1rem}.ml-4{margin-left:1rem}.mt-8{margin-top:2rem}.ml-12{margin-left:3rem}.-mt-px{margin-top:-1px}.max-w-xl{max-width:36rem}.max-w-6xl{max-width:72rem}.min-h-screen{min-height:100vh}.overflow-hidden{overflow:hidden}.p-6{padding:1.5rem}.py-4{padding-top:1rem;padding-bottom:1rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.pt-8{padding-top:2rem}.fixed{position:fixed}.relative{position:relative}.top-0{top:0}.right-0{right:0}.shadow{box-shadow:0 1px 3px 0 rgba(0,0,0,.1),0 1px 2px 0 rgba(0,0,0,.06)}.text-center{text-align:center}.text-gray-200{--text-opacity:1;color:#edf2f7;color:rgba(237,242,247,var(--text-opacity))}.text-gray-300{--text-opacity:1;color:#e2e8f0;color:rgba(226,232,240,var(--text-opacity))}.text-gray-400{--text-opacity:1;color:#cbd5e0;color:rgba(203,213,224,var(--text-opacity))}.text-gray-500{--text-opacity:1;color:#a0aec0;color:rgba(160,174,192,var(--text-opacity))}.text-gray-600{--text-opacity:1;color:#718096;color:rgba(113,128,150,var(--text-opacity))}.text-gray-700{--text-opacity:1;color:#4a5568;color:rgba(74,85,104,var(--text-opacity))}.text-gray-900{--text-opacity:1;color:#1a202c;color:rgba(26,32,44,var(--text-opacity))}.uppercase{text-transform:uppercase}.underline{text-decoration:underline}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.tracking-wider{letter-spacing:.05em}.w-5{width:1.25rem}.w-8{width:2rem}.w-auto{width:auto}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}@-webkit-keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@-webkit-keyframes ping{0%{transform:scale(1);opacity:1}75%,to{transform:scale(2);opacity:0}}@keyframes ping{0%{transform:scale(1);opacity:1}75%,to{transform:scale(2);opacity:0}}@-webkit-keyframes pulse{0%,to{opacity:1}50%{opacity:.5}}@keyframes pulse{0%,to{opacity:1}50%{opacity:.5}}@-webkit-keyframes bounce{0%,to{transform:translateY(-25%);-webkit-animation-timing-function:cubic-bezier(.8,0,1,1);animation-timing-function:cubic-bezier(.8,0,1,1)}50%{transform:translateY(0);-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1)}}@keyframes bounce{0%,to{transform:translateY(-25%);-webkit-animation-timing-function:cubic-bezier(.8,0,1,1);animation-timing-function:cubic-bezier(.8,0,1,1)}50%{transform:translateY(0);-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1)}}@media (min-width:640px){.sm\\:rounded-lg{border-radius:.5rem}.sm\\:block{display:block}.sm\\:items-center{align-items:center}.sm\\:justify-start{justify-content:flex-start}.sm\\:justify-between{justify-content:space-between}.sm\\:h-20{height:5rem}.sm\\:ml-0{margin-left:0}.sm\\:px-6{padding-left:1.5rem;padding-right:1.5rem}.sm\\:pt-0{padding-top:0}.sm\\:text-left{text-align:left}.sm\\:text-right{text-align:right}}@media (min-width:768px){.md\\:border-t-0{border-top-width:0}.md\\:border-l{border-left-width:1px}.md\\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}}@media (min-width:1024px){.lg\\:px-8{padding-left:2rem;padding-right:2rem}}@media (prefers-color-scheme:dark){.dark\\:bg-gray-800{--bg-opacity:1;background-color:#2d3748;background-color:rgba(45,55,72,var(--bg-opacity))}.dark\\:bg-gray-900{--bg-opacity:1;background-color:#1a202c;background-color:rgba(26,32,44,var(--bg-opacity))}.dark\\:border-gray-700{--border-opacity:1;border-color:#4a5568;border-color:rgba(74,85,104,var(--border-opacity))}.dark\\:text-white{--text-opacity:1;color:#fff;color:rgba(255,255,255,var(--text-opacity))}.dark\\:text-gray-300 { --text-opacity: 1; color: #e2e8f0; color: rgba(226,232,240,var(--text-opacity)) }}\n        </style>\n\n        <style>\n            body {\n                font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";\n            }\n        </style>\n    </head>\n    <body class=\"antialiased\">\n        <div class=\"relative flex items-top justify-center min-h-screen bg-gray-100 dark:bg-gray-900 sm:items-center sm:pt-0\" role=\"main\">\n            <div class=\"max-w-xl mx-auto sm:px-6 lg:px-8\">\n                <div class=\"flex items-center pt-8 sm:justify-start sm:pt-0\">\n                    <h1 class=\"px-4 text-lg dark:text-gray-300 text-gray-700 border-r border-gray-400 tracking-wider\">\n                        404                    </h1>\n\n                    <div class=\"ml-4 text-lg dark:text-gray-300 text-gray-700 uppercase tracking-wider\">\n                        Not Found                    </div>\n                </div>\n            </div>\n        </div>\n    </body>\n</html>\n\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-30T01:25:23.078Z",
    "modified": "2026-01-30T01:26:05.610Z"
  },
  {
    "projectId": "eb0756a5-62c6-4448-a02d-a326d56f1949",
    "testId": "4beae50a-54bd-4855-a3a2-d6637df2063c",
    "userId": "a4b8d4c8-2041-70db-c1a1-eccd7d9aa439",
    "title": "TC004-auth me functionality",
    "description": "Verify that the /auth/me endpoint returns the current authenticated user's information when provided a valid token.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_auth_me_functionality():\n    login_url = f\"{BASE_URL}/auth/login\"\n    auth_me_url = f\"{BASE_URL}/auth/me\"\n    logout_url = f\"{BASE_URL}/auth/logout\"\n\n    # Use known admin credentials that have access to Alert and Case Verification features\n    credentials = {\n        \"email\": \"admin@example.com\",\n        \"password\": \"adminpassword\"\n    }\n\n    try:\n        # Login to get token\n        login_response = requests.post(login_url, json=credentials, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed: {login_response.text}\"\n        login_data = login_response.json()\n        assert \"token\" in login_data, \"Token not in login response\"\n\n        token = login_data[\"token\"]\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Call /auth/me to get current user info\n        me_response = requests.get(auth_me_url, headers=headers, timeout=TIMEOUT)\n        assert me_response.status_code == 200, f\"/auth/me failed: {me_response.text}\"\n\n        user_info = me_response.json()\n        # Validate returned user info contains expected keys\n        assert \"id\" in user_info, \"User id missing in auth me response\"\n        assert \"email\" in user_info, \"User email missing in auth me response\"\n        assert user_info[\"email\"] == credentials[\"email\"], \"Returned user email does not match login email\"\n        # Optionally check roles related to Alert and Case Verification are included\n        assert \"roles\" in user_info, \"User roles missing in auth me response\"\n        roles = user_info[\"roles\"]\n        assert any(r in roles for r in [\"public\", \"auth\", \"admin\"]), \"Expected roles not present in user roles\"\n\n    finally:\n        # Logout to invalidate token\n        if 'token' in locals():\n            headers = {\"Authorization\": f\"Bearer {token}\"}\n            logout_response = requests.post(logout_url, headers=headers, timeout=TIMEOUT)\n            assert logout_response.status_code == 200, f\"Logout failed: {logout_response.text}\"\n\ntest_auth_me_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 48, in <module>\n  File \"<string>\", line 20, in test_auth_me_functionality\nAssertionError: Login failed: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\n        <title>Not Found</title>\n\n        <style>\n            /*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}a{background-color:transparent}code{font-family:monospace,monospace;font-size:1em}[hidden]{display:none}html{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5}*,:after,:before{box-sizing:border-box;border:0 solid #e2e8f0}a{color:inherit;text-decoration:inherit}code{font-family:Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}svg,video{display:block;vertical-align:middle}video{max-width:100%;height:auto}.bg-white{--bg-opacity:1;background-color:#fff;background-color:rgba(255,255,255,var(--bg-opacity))}.bg-gray-100{--bg-opacity:1;background-color:#f7fafc;background-color:rgba(247,250,252,var(--bg-opacity))}.border-gray-200{--border-opacity:1;border-color:#edf2f7;border-color:rgba(237,242,247,var(--border-opacity))}.border-gray-400{--border-opacity:1;border-color:#cbd5e0;border-color:rgba(203,213,224,var(--border-opacity))}.border-t{border-top-width:1px}.border-r{border-right-width:1px}.flex{display:flex}.grid{display:grid}.hidden{display:none}.items-center{align-items:center}.justify-center{justify-content:center}.font-semibold{font-weight:600}.h-5{height:1.25rem}.h-8{height:2rem}.h-16{height:4rem}.text-sm{font-size:.875rem}.text-lg{font-size:1.125rem}.leading-7{line-height:1.75rem}.mx-auto{margin-left:auto;margin-right:auto}.ml-1{margin-left:.25rem}.mt-2{margin-top:.5rem}.mr-2{margin-right:.5rem}.ml-2{margin-left:.5rem}.mt-4{margin-top:1rem}.ml-4{margin-left:1rem}.mt-8{margin-top:2rem}.ml-12{margin-left:3rem}.-mt-px{margin-top:-1px}.max-w-xl{max-width:36rem}.max-w-6xl{max-width:72rem}.min-h-screen{min-height:100vh}.overflow-hidden{overflow:hidden}.p-6{padding:1.5rem}.py-4{padding-top:1rem;padding-bottom:1rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.pt-8{padding-top:2rem}.fixed{position:fixed}.relative{position:relative}.top-0{top:0}.right-0{right:0}.shadow{box-shadow:0 1px 3px 0 rgba(0,0,0,.1),0 1px 2px 0 rgba(0,0,0,.06)}.text-center{text-align:center}.text-gray-200{--text-opacity:1;color:#edf2f7;color:rgba(237,242,247,var(--text-opacity))}.text-gray-300{--text-opacity:1;color:#e2e8f0;color:rgba(226,232,240,var(--text-opacity))}.text-gray-400{--text-opacity:1;color:#cbd5e0;color:rgba(203,213,224,var(--text-opacity))}.text-gray-500{--text-opacity:1;color:#a0aec0;color:rgba(160,174,192,var(--text-opacity))}.text-gray-600{--text-opacity:1;color:#718096;color:rgba(113,128,150,var(--text-opacity))}.text-gray-700{--text-opacity:1;color:#4a5568;color:rgba(74,85,104,var(--text-opacity))}.text-gray-900{--text-opacity:1;color:#1a202c;color:rgba(26,32,44,var(--text-opacity))}.uppercase{text-transform:uppercase}.underline{text-decoration:underline}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.tracking-wider{letter-spacing:.05em}.w-5{width:1.25rem}.w-8{width:2rem}.w-auto{width:auto}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}@-webkit-keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}@-webkit-keyframes ping{0%{transform:scale(1);opacity:1}75%,to{transform:scale(2);opacity:0}}@keyframes ping{0%{transform:scale(1);opacity:1}75%,to{transform:scale(2);opacity:0}}@-webkit-keyframes pulse{0%,to{opacity:1}50%{opacity:.5}}@keyframes pulse{0%,to{opacity:1}50%{opacity:.5}}@-webkit-keyframes bounce{0%,to{transform:translateY(-25%);-webkit-animation-timing-function:cubic-bezier(.8,0,1,1);animation-timing-function:cubic-bezier(.8,0,1,1)}50%{transform:translateY(0);-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1)}}@keyframes bounce{0%,to{transform:translateY(-25%);-webkit-animation-timing-function:cubic-bezier(.8,0,1,1);animation-timing-function:cubic-bezier(.8,0,1,1)}50%{transform:translateY(0);-webkit-animation-timing-function:cubic-bezier(0,0,.2,1);animation-timing-function:cubic-bezier(0,0,.2,1)}}@media (min-width:640px){.sm\\:rounded-lg{border-radius:.5rem}.sm\\:block{display:block}.sm\\:items-center{align-items:center}.sm\\:justify-start{justify-content:flex-start}.sm\\:justify-between{justify-content:space-between}.sm\\:h-20{height:5rem}.sm\\:ml-0{margin-left:0}.sm\\:px-6{padding-left:1.5rem;padding-right:1.5rem}.sm\\:pt-0{padding-top:0}.sm\\:text-left{text-align:left}.sm\\:text-right{text-align:right}}@media (min-width:768px){.md\\:border-t-0{border-top-width:0}.md\\:border-l{border-left-width:1px}.md\\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}}@media (min-width:1024px){.lg\\:px-8{padding-left:2rem;padding-right:2rem}}@media (prefers-color-scheme:dark){.dark\\:bg-gray-800{--bg-opacity:1;background-color:#2d3748;background-color:rgba(45,55,72,var(--bg-opacity))}.dark\\:bg-gray-900{--bg-opacity:1;background-color:#1a202c;background-color:rgba(26,32,44,var(--bg-opacity))}.dark\\:border-gray-700{--border-opacity:1;border-color:#4a5568;border-color:rgba(74,85,104,var(--border-opacity))}.dark\\:text-white{--text-opacity:1;color:#fff;color:rgba(255,255,255,var(--text-opacity))}.dark\\:text-gray-300 { --text-opacity: 1; color: #e2e8f0; color: rgba(226,232,240,var(--text-opacity)) }}\n        </style>\n\n        <style>\n            body {\n                font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";\n            }\n        </style>\n    </head>\n    <body class=\"antialiased\">\n        <div class=\"relative flex items-top justify-center min-h-screen bg-gray-100 dark:bg-gray-900 sm:items-center sm:pt-0\" role=\"main\">\n            <div class=\"max-w-xl mx-auto sm:px-6 lg:px-8\">\n                <div class=\"flex items-center pt-8 sm:justify-start sm:pt-0\">\n                    <h1 class=\"px-4 text-lg dark:text-gray-300 text-gray-700 border-r border-gray-400 tracking-wider\">\n                        404                    </h1>\n\n                    <div class=\"ml-4 text-lg dark:text-gray-300 text-gray-700 uppercase tracking-wider\">\n                        Not Found                    </div>\n                </div>\n            </div>\n        </div>\n    </body>\n</html>\n\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-30T01:25:23.083Z",
    "modified": "2026-01-30T01:26:02.483Z"
  },
  {
    "projectId": "eb0756a5-62c6-4448-a02d-a326d56f1949",
    "testId": "bf93e93f-18c9-4d57-b693-4e3f750dd98f",
    "userId": "a4b8d4c8-2041-70db-c1a1-eccd7d9aa439",
    "title": "TC005-public alerts retrieval",
    "description": "Verify that the /public/alerts endpoint returns a list of active public alerts accessible without authentication.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_public_alerts_retrieval():\n    url = f\"{BASE_URL}/public/alerts\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    # Validate response status code\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        alerts = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate that the response is a list (of active public alerts)\n    assert isinstance(alerts, list), \"Response JSON is not a list\"\n\n    # Optional: Validate structure of each alert item if possible\n    for alert in alerts:\n        assert isinstance(alert, dict), \"Each alert should be a dictionary\"\n        # Basic keys that might be expected in an alert object\n        # Since no schema details, check at least for id and active status\n        assert \"id\" in alert, \"Alert item missing 'id'\"\n        assert \"active\" in alert, \"Alert item missing 'active'\"\n        assert alert[\"active\"] is True, \"Alert item is not active\"\n\ntest_public_alerts_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 13, in test_public_alerts_retrieval\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/public/alerts\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 37, in <module>\n  File \"<string>\", line 15, in test_public_alerts_retrieval\nAssertionError: Request to http://localhost:8000/public/alerts failed: 404 Client Error: Not Found for url: http://localhost:8000/public/alerts\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-30T01:25:23.088Z",
    "modified": "2026-01-30T01:26:02.613Z"
  },
  {
    "projectId": "eb0756a5-62c6-4448-a02d-a326d56f1949",
    "testId": "3900ff56-5a69-4bd3-9358-081a7acc0f99",
    "userId": "a4b8d4c8-2041-70db-c1a1-eccd7d9aa439",
    "title": "TC006-alerts management",
    "description": "Verify that the /alerts endpoint supports listing alerts for authenticated users and allows creation of new alerts with valid data.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Credentials for the users representing public, auth user, and admin roles\n# For testing, these should be set to valid existing users or created dynamically.\n# Since instructions do not provide user creation, assume existing users:\nUSERS = {\n    \"public\": None,  # no auth token\n    \"auth\": {\"email\": \"user@example.com\", \"password\": \"userpass\"},\n    \"admin\": {\"email\": \"admin@example.com\", \"password\": \"adminpass\"},\n}\n\ndef login(email, password):\n    url = f\"{BASE_URL}/auth/login\"\n    try:\n        resp = requests.post(url, json={\"email\": email, \"password\": password}, timeout=TIMEOUT)\n        resp.raise_for_status()\n        token = resp.json().get(\"token\")\n        assert token, \"Token not found in login response\"\n        return token\n    except Exception as e:\n        raise RuntimeError(f\"Login failed for {email}: {e}\")\n\ndef test_alerts_management():\n    # 1. Test /alerts listing for authenticated users (auth and admin)\n    # 2. Test creation of alert with valid data for both roles\n    # 3. Ensure public role cannot access /alerts\n    # 4. Cleanup created alerts after test\n\n    headers_auth = {}\n    headers_admin = {}\n    created_alerts = []\n\n    # Login as auth user\n    token_auth = login(USERS[\"auth\"][\"email\"], USERS[\"auth\"][\"password\"])\n    headers_auth = {\"Authorization\": f\"Bearer {token_auth}\", \"Content-Type\": \"application/json\"}\n\n    # Login as admin user\n    token_admin = login(USERS[\"admin\"][\"email\"], USERS[\"admin\"][\"password\"])\n    headers_admin = {\"Authorization\": f\"Bearer {token_admin}\", \"Content-Type\": \"application/json\"}\n\n    # 1.a. Auth user lists alerts\n    url_alerts = f\"{BASE_URL}/alerts\"\n    try:\n        resp = requests.get(url_alerts, headers=headers_auth, timeout=TIMEOUT)\n        resp.raise_for_status()\n        alerts_list = resp.json()\n        assert isinstance(alerts_list, list), \"Alerts list for auth user should be a list\"\n    except Exception as e:\n        raise AssertionError(f\"Auth user failed to list alerts: {e}\")\n\n    # 1.b. Admin user lists alerts\n    try:\n        resp = requests.get(url_alerts, headers=headers_admin, timeout=TIMEOUT)\n        resp.raise_for_status()\n        alerts_list_admin = resp.json()\n        assert isinstance(alerts_list_admin, list), \"Alerts list for admin user should be a list\"\n    except Exception as e:\n        raise AssertionError(f\"Admin user failed to list alerts: {e}\")\n\n    # 1.c. Public (no auth) user tries to list alerts, should be unauthorized or forbidden\n    try:\n        resp = requests.get(url_alerts, timeout=TIMEOUT)\n        assert resp.status_code in (401, 403), \"Public user should not access /alerts\"\n    except Exception as e:\n        raise AssertionError(f\"Public user access to /alerts did not fail as expected: {e}\")\n\n    # Prepare valid alert creation payload\n    # Example alert fields inferred (since not explicitly given in PRD):\n    alert_payload = {\n        \"title\": f\"Test Alert {uuid.uuid4()}\",\n        \"message\": \"This is a test alert created by automated test.\",\n        \"level\": \"info\",  # assuming level field exists, e.g., info, warning, critical\n        \"active\": True\n    }\n\n    # 2.a. Auth user creates an alert\n    alert_id_auth = None\n    try:\n        resp = requests.post(url_alerts, headers=headers_auth, json=alert_payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        alert_created = resp.json()\n        assert \"id\" in alert_created, \"Created alert response must contain 'id'\"\n        alert_id_auth = alert_created[\"id\"]\n        created_alerts.append((alert_id_auth, headers_auth))\n    except Exception as e:\n        raise AssertionError(f\"Auth user failed to create alert: {e}\")\n\n    # 2.b. Admin user creates an alert\n    alert_id_admin = None\n    try:\n        resp = requests.post(url_alerts, headers=headers_admin, json=alert_payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        alert_created_admin = resp.json()\n        assert \"id\" in alert_created_admin, \"Created alert response must contain 'id'\"\n        alert_id_admin = alert_created_admin[\"id\"]\n        created_alerts.append((alert_id_admin, headers_admin))\n    except Exception as e:\n        raise AssertionError(f\"Admin user failed to create alert: {e}\")\n\n    # 2.c. Public user tries to create alert, should fail\n    try:\n        resp = requests.post(url_alerts, json=alert_payload, timeout=TIMEOUT)\n        assert resp.status_code in (401, 403), \"Public user should not create alerts\"\n    except Exception as e:\n        raise AssertionError(f\"Public user create alert did not fail as expected: {e}\")\n\n    # Cleanup: delete created alerts\n    for alert_id, auth_headers in created_alerts:\n        try:\n            url_delete = f\"{url_alerts}/{alert_id}\"\n            resp = requests.delete(url_delete, headers=auth_headers, timeout=TIMEOUT)\n            # response might be 200 or 204 for successful delete\n            assert resp.status_code in (200, 204), f\"Failed to delete alert ID {alert_id}\"\n        except Exception as e:\n            print(f\"Warning: Failed to delete alert ID {alert_id}: {e}\")\n\ntest_alerts_management()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 20, in login\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 121, in <module>\n  File \"<string>\", line 38, in test_alerts_management\n  File \"<string>\", line 25, in login\nRuntimeError: Login failed for user@example.com: 404 Client Error: Not Found for url: http://localhost:8000/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-30T01:25:23.093Z",
    "modified": "2026-01-30T01:26:02.601Z"
  },
  {
    "projectId": "eb0756a5-62c6-4448-a02d-a326d56f1949",
    "testId": "43273726-4101-4c57-b4b1-2c29d0ad36cd",
    "userId": "a4b8d4c8-2041-70db-c1a1-eccd7d9aa439",
    "title": "TC007-alerts update and delete",
    "description": "Verify that the /alerts/{id} endpoint allows updating and deleting alerts by authenticated users with proper authorization.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Credentials for users with different roles\nUSERS = {\n    \"admin\": {\"email\": \"admin@example.com\", \"password\": \"AdminPass123\"},\n    \"auth\": {\"email\": \"user@example.com\", \"password\": \"UserPass123\"},\n    \"public\": None  # No credentials for public\n}\n\ndef login(user_credentials):\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}/auth/login\",\n            json={\n                \"email\": user_credentials[\"email\"],\n                \"password\": user_credentials[\"password\"]\n            },\n            timeout=TIMEOUT\n        )\n        resp.raise_for_status()\n        token = resp.json().get(\"token\")\n        assert token, \"Login failed: No token returned\"\n        return token\n    except Exception as e:\n        raise Exception(f\"Login failed: {e}\")\n\ndef create_alert(token, alert_data):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}/alerts\",\n            headers=headers,\n            json=alert_data,\n            timeout=TIMEOUT\n        )\n        resp.raise_for_status()\n        alert = resp.json()\n        alert_id = alert.get(\"id\")\n        assert alert_id, \"Create alert failed: No ID returned\"\n        return alert_id\n    except Exception as e:\n        raise Exception(f\"Create alert failed: {e}\")\n\ndef update_alert(token, alert_id, update_data):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    try:\n        resp = requests.put(\n            f\"{BASE_URL}/alerts/{alert_id}\",\n            headers=headers,\n            json=update_data,\n            timeout=TIMEOUT\n        )\n        resp.raise_for_status()\n        updated_alert = resp.json()\n        return updated_alert\n    except Exception as e:\n        raise Exception(f\"Update alert failed: {e}\")\n\ndef delete_alert(token, alert_id):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    try:\n        resp = requests.delete(\n            f\"{BASE_URL}/alerts/{alert_id}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        resp.raise_for_status()\n        return resp.status_code\n    except Exception as e:\n        raise Exception(f\"Delete alert failed: {e}\")\n\ndef test_alerts_update_and_delete():\n    # Alert data for creation\n    alert_data = {\n        \"title\": \"Test Alert\",\n        \"message\": \"This is a test alert for update and delete.\",\n        \"active\": True\n    }\n    # Update data to modify the alert\n    update_data = {\n        \"title\": \"Updated Test Alert\",\n        \"message\": \"This alert has been updated.\",\n        \"active\": False\n    }\n\n    # Testing with admin role\n    admin_token = login(USERS[\"admin\"])\n\n    alert_id = None\n    try:\n        alert_id = create_alert(admin_token, alert_data)\n\n        # Update the alert\n        updated_alert = update_alert(admin_token, alert_id, update_data)\n        assert updated_alert[\"id\"] == alert_id\n        assert updated_alert[\"title\"] == update_data[\"title\"]\n        assert updated_alert[\"message\"] == update_data[\"message\"]\n        assert updated_alert[\"active\"] == update_data[\"active\"]\n\n        # Delete the alert\n        del_status = delete_alert(admin_token, alert_id)\n        assert del_status == 200 or del_status == 204\n        alert_id = None  # Mark as deleted to skip deletion in finally\n\n    finally:\n        # Cleanup: delete alert if it still exists\n        if alert_id is not None:\n            try:\n                delete_alert(admin_token, alert_id)\n            except Exception:\n                pass\n\n    # Testing update and delete with authenticated non-admin user (should be unauthorized)\n    auth_token = login(USERS[\"auth\"])\n    # Create alert as admin to test update/delete with auth user\n    alert_id_auth_test = None\n    try:\n        alert_id_auth_test = create_alert(admin_token, alert_data)\n\n        # Attempt update with auth user - expect failure (403 or 401)\n        headers_auth = {\"Authorization\": f\"Bearer {auth_token}\"}\n        resp_update = requests.put(\n            f\"{BASE_URL}/alerts/{alert_id_auth_test}\",\n            headers=headers_auth,\n            json=update_data,\n            timeout=TIMEOUT\n        )\n        assert resp_update.status_code in (401, 403)\n\n        # Attempt delete with auth user - expect failure (403 or 401)\n        resp_delete = requests.delete(\n            f\"{BASE_URL}/alerts/{alert_id_auth_test}\",\n            headers=headers_auth,\n            timeout=TIMEOUT\n        )\n        assert resp_delete.status_code in (401, 403)\n\n    finally:\n        # Cleanup: delete alert as admin\n        if alert_id_auth_test is not None:\n            try:\n                delete_alert(admin_token, alert_id_auth_test)\n            except Exception:\n                pass\n\n    # Testing unauthenticated (public) user update and delete - should be unauthorized\n    if USERS[\"public\"] is None:\n        # Attempt update without auth token\n        resp_update_public = requests.put(\n            f\"{BASE_URL}/alerts/1\",\n            json=update_data,\n            timeout=TIMEOUT\n        )\n        assert resp_update_public.status_code == 401 or resp_update_public.status_code == 403\n\n        # Attempt delete without auth token\n        resp_delete_public = requests.delete(\n            f\"{BASE_URL}/alerts/1\",\n            timeout=TIMEOUT\n        )\n        assert resp_delete_public.status_code == 401 or resp_delete_public.status_code == 403\n\ntest_alerts_update_and_delete()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 23, in login\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 166, in <module>\n  File \"<string>\", line 90, in test_alerts_update_and_delete\n  File \"<string>\", line 28, in login\nException: Login failed: 404 Client Error: Not Found for url: http://localhost:8000/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-30T01:25:23.098Z",
    "modified": "2026-01-30T01:26:05.611Z"
  },
  {
    "projectId": "eb0756a5-62c6-4448-a02d-a326d56f1949",
    "testId": "ab34e95b-9e88-4c7b-b739-750f2cb01d89",
    "userId": "a4b8d4c8-2041-70db-c1a1-eccd7d9aa439",
    "title": "TC008-cases management",
    "description": "Verify that the /cases endpoint supports listing all cases and creating new cases with valid data for authenticated users.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_cases_management():\n    # User credentials for roles to test: public (no auth), auth user, admin\n    # For this test, we'll use an auth user and an admin user for testing the /cases endpoint.\n    # Assuming we have test users set with credentials:\n    users = {\n        \"auth_user\": {\"email\": \"user@example.com\", \"password\": \"userpassword\"},\n        \"admin\": {\"email\": \"admin@example.com\", \"password\": \"adminpassword\"},\n        # public role requires no authentication and should not allow GET/POST on /cases (restricted)\n    }\n\n    def login(user):\n        resp = requests.post(f\"{BASE_URL}/auth/login\",\n                             json={\"email\": user[\"email\"], \"password\": user[\"password\"]},\n                             timeout=TIMEOUT)\n        resp.raise_for_status()\n        token = resp.json().get(\"token\")\n        assert token, \"Login response missing token\"\n        return token\n\n    def auth_headers(token):\n        return {\"Authorization\": f\"Bearer {token}\"}\n\n    # Sample case data for creation based on common disease case attributes inferred\n    new_case_data = {\n        \"patient_name\": \"Test Patient\",\n        \"disease\": \"Test Disease\",\n        \"status\": \"confirmed\",\n        \"date_reported\": \"2026-01-28\",\n        \"location\": \"Test Location\",\n        \"notes\": \"Test case created by automated test\"\n    }\n\n    # FUNCTION TO CREATE a case and return its ID\n    def create_case(token):\n        headers = auth_headers(token)\n        resp = requests.post(f\"{BASE_URL}/cases\", json=new_case_data, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        assert \"id\" in data, \"Response from case creation missing 'id'\"\n        return data[\"id\"]\n\n    # FUNCTION TO DELETE a case to clean up test data (if API supported DELETE, here assuming no delete endpoint in PRD for cases)\n    # So no delete here, just testing create and list\n\n    # Test for authenticated user role\n    token_user = login(users[\"auth_user\"])\n\n    try:\n        # List cases\n        resp_list = requests.get(f\"{BASE_URL}/cases\", headers=auth_headers(token_user), timeout=TIMEOUT)\n        resp_list.raise_for_status()\n        cases_list = resp_list.json()\n        assert isinstance(cases_list, list), \"/cases GET should return a list\"\n\n        # Create a new case\n        case_id = create_case(token_user)\n\n        # Verify case is listed after creation\n        resp_list2 = requests.get(f\"{BASE_URL}/cases\", headers=auth_headers(token_user), timeout=TIMEOUT)\n        resp_list2.raise_for_status()\n        cases_list2 = resp_list2.json()\n        assert any(c.get(\"id\") == case_id for c in cases_list2), \"Newly created case not found in cases list\"\n\n    finally:\n        # No deletion of case endpoint, so no cleanup possible here for case resource\n\n        pass\n\n    # Test for admin role\n    token_admin = login(users[\"admin\"])\n\n    try:\n        # List cases for admin\n        resp_list_admin = requests.get(f\"{BASE_URL}/cases\", headers=auth_headers(token_admin), timeout=TIMEOUT)\n        resp_list_admin.raise_for_status()\n        cases_list_admin = resp_list_admin.json()\n        assert isinstance(cases_list_admin, list), \"/cases GET by admin should return a list\"\n\n        # Create a new case as admin\n        case_id_admin = create_case(token_admin)\n\n        # Verify case is listed after creation\n        resp_list_admin2 = requests.get(f\"{BASE_URL}/cases\", headers=auth_headers(token_admin), timeout=TIMEOUT)\n        resp_list_admin2.raise_for_status()\n        cases_list_admin2 = resp_list_admin2.json()\n        assert any(c.get(\"id\") == case_id_admin for c in cases_list_admin2), \"Newly created case by admin not found in cases list\"\n\n    finally:\n        # No deletion endpoint to cleanup created case\n\n        pass\n\n    # Test that public (no token) cannot access /cases endpoint (should be unauthorized)\n    resp_public_get = requests.get(f\"{BASE_URL}/cases\", timeout=TIMEOUT)\n    assert resp_public_get.status_code in (401, 403), \"Public access to /cases GET should be unauthorized\"\n\n    resp_public_post = requests.post(f\"{BASE_URL}/cases\", json=new_case_data, timeout=TIMEOUT)\n    assert resp_public_post.status_code in (401, 403), \"Public access to /cases POST should be unauthorized\"\n\n\ntest_cases_management()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 106, in <module>\n  File \"<string>\", line 51, in test_cases_management\n  File \"<string>\", line 20, in login\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-30T01:25:23.103Z",
    "modified": "2026-01-30T01:26:08.597Z"
  },
  {
    "projectId": "eb0756a5-62c6-4448-a02d-a326d56f1949",
    "testId": "d4e16425-d9ec-4ebf-ada6-26250b4f16d9",
    "userId": "a4b8d4c8-2041-70db-c1a1-eccd7d9aa439",
    "title": "TC009-case details and update",
    "description": "Verify that the /cases/{id} endpoint allows retrieving case details and updating case information for authenticated users.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef login(email: str, password: str):\n    url = f\"{BASE_URL}/auth/login\"\n    payload = {\"email\": email, \"password\": password}\n    try:\n        resp = requests.post(url, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        token = resp.json().get(\"token\") or resp.json().get(\"access_token\")\n        assert token, \"No token found in login response\"\n        return token\n    except Exception as e:\n        raise AssertionError(f\"Login failed for {email}: {e}\")\n\ndef create_case(auth_token):\n    url = f\"{BASE_URL}/cases\"\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    # Example case data, should be consistent with API schema (minimal required fields)\n    payload = {\n        \"patient_name\": \"Test Patient\",\n        \"disease\": \"Test Disease\",\n        \"status\": \"active\",\n        \"description\": \"Test case created for TC009.\",\n        \"alert_verified\": False,\n        \"case_verified\": False\n    }\n    try:\n        resp = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        case_id = data.get(\"id\") or data.get(\"case_id\")\n        assert case_id, \"No case id returned on creation\"\n        return case_id\n    except Exception as e:\n        raise AssertionError(f\"Case creation failed: {e}\")\n\ndef delete_case(auth_token, case_id):\n    url = f\"{BASE_URL}/cases/{case_id}\"\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    try:\n        resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n        # 204 No Content or 200 OK expected on delete success\n        assert resp.status_code in (200, 204), f\"Failed to delete case {case_id}, status: {resp.status_code}\"\n    except Exception as e:\n        # Don't raise to ensure cleanup attempt but log if needed\n        pass\n\ndef test_case_details_and_update():\n    # Credentials for public, auth user, and admin roles (placeholders - replace with actual test users)\n    users = {\n        \"public\": None,\n        \"auth\": {\"email\": \"user_auth\", \"password\": \"auth_pass\"},\n        \"admin\": {\"email\": \"admin_user\", \"password\": \"admin_pass\"}\n    }\n    # Login as authenticated user\n    auth_token = login(users[\"auth\"][\"email\"], users[\"auth\"][\"password\"])\n    admin_token = login(users[\"admin\"][\"email\"], users[\"admin\"][\"password\"])\n\n    # Create a case to test on\n    case_id = None\n    try:\n        case_id = create_case(auth_token)\n\n        # Retrieve case details as authenticated user\n        url = f\"{BASE_URL}/cases/{case_id}\"\n        headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n        resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        case_data = resp.json()\n        assert case_data.get(\"id\") == case_id or case_data.get(\"case_id\") == case_id\n\n        # Verify Alert and Case Verification fields are present (recently added features)\n        assert \"alert_verified\" in case_data\n        assert \"case_verified\" in case_data\n\n        # Update the case details as authenticated user\n        update_payload = {\"description\": \"Updated description for test case.\", \"alert_verified\": True, \"case_verified\": True}\n        resp = requests.put(url, json=update_payload, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n        updated_data = resp.json()\n        assert updated_data.get(\"description\") == update_payload[\"description\"]\n        assert updated_data.get(\"alert_verified\") == True\n        assert updated_data.get(\"case_verified\") == True\n\n        # Retrieve case details as admin to verify update\n        headers_admin = {\"Authorization\": f\"Bearer {admin_token}\"}\n        resp_admin = requests.get(url, headers=headers_admin, timeout=TIMEOUT)\n        resp_admin.raise_for_status()\n        case_data_admin = resp_admin.json()\n        assert case_data_admin.get(\"description\") == update_payload[\"description\"]\n        assert case_data_admin.get(\"alert_verified\") is True\n        assert case_data_admin.get(\"case_verified\") is True\n\n        # Attempt retrieving case details without auth (public role) should fail (401 or 403)\n        resp_public = requests.get(url, timeout=TIMEOUT)\n        assert resp_public.status_code in (401, 403)\n\n    finally:\n        if case_id:\n            try:\n                delete_case(auth_token, case_id)\n            except Exception:\n                pass\n\ntest_case_details_and_update()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 11, in login\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 108, in <module>\n  File \"<string>\", line 59, in test_case_details_and_update\n  File \"<string>\", line 16, in login\nAssertionError: Login failed for user_auth: 404 Client Error: Not Found for url: http://localhost:8000/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-30T01:25:23.108Z",
    "modified": "2026-01-30T01:26:33.889Z"
  },
  {
    "projectId": "eb0756a5-62c6-4448-a02d-a326d56f1949",
    "testId": "d5eb2915-df0d-4427-86f4-a385d1a087f2",
    "userId": "a4b8d4c8-2041-70db-c1a1-eccd7d9aa439",
    "title": "TC010-case history retrieval",
    "description": "Verify that the /cases/{id}/history endpoint returns the history of changes for a specific case.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\nPUBLIC_USER = {\"username\": \"public_user\", \"password\": \"public_pass\"}\nAUTH_USER = {\"username\": \"auth_user\", \"password\": \"auth_pass\"}\nADMIN_USER = {\"username\": \"admin_user\", \"password\": \"admin_pass\"}\n\ndef login(user):\n    resp = requests.post(f\"{BASE_URL}/auth/login\", json=user, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    token = data.get(\"token\") or data.get(\"access_token\")\n    assert token, \"Login did not return a token\"\n    return token\n\ndef create_case(token):\n    case_data = {\n        \"patient_name\": \"Test Patient\",\n        \"disease\": \"TestDisease\",\n        \"status\": \"new\",\n        \"description\": \"Case created for testing history retrieval\"\n    }\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.post(f\"{BASE_URL}/cases\", json=case_data, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    case = resp.json()\n    case_id = case.get(\"id\")\n    assert case_id, \"Created case does not have an ID\"\n    return case_id\n\ndef delete_case(case_id, token):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.delete(f\"{BASE_URL}/cases/{case_id}\", headers=headers, timeout=TIMEOUT)\n    # It's okay if delete fails for cleanup, so only catch exceptions silently\n    try:\n        resp.raise_for_status()\n    except Exception:\n        pass\n\ndef update_case(case_id, token):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    update_data = {\"status\": \"verified\", \"description\": \"Updated case status to verified\"}\n    resp = requests.put(f\"{BASE_URL}/cases/{case_id}\", json=update_data, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef test_case_history_retrieval():\n    # Login users\n    token_public = None  # Public does not require token\n    token_auth = login(AUTH_USER)\n    token_admin = login(ADMIN_USER)\n\n    # Create a case as auth user to test history (we use auth_user for creation)\n    case_id = None\n    try:\n        case_id = create_case(token_auth)\n\n        # Make an update to create history entries\n        update_case(case_id, token_auth)\n\n        # Test retrieval of case history as:\n        # 1) public (no authentication)\n        resp_public = requests.get(f\"{BASE_URL}/cases/{case_id}/history\", timeout=TIMEOUT)\n        # Public may or may not have access; we expect 401 or 403 or 200 with limited info\n        if resp_public.status_code == 200:\n            history_public = resp_public.json()\n            assert isinstance(history_public, list), \"Public history response should be a list\"\n        else:\n            assert resp_public.status_code in (401,403), \"Unexpected status for public role\"\n\n        # 2) authenticated user\n        headers_auth = {\"Authorization\": f\"Bearer {token_auth}\"}\n        resp_auth = requests.get(f\"{BASE_URL}/cases/{case_id}/history\", headers=headers_auth, timeout=TIMEOUT)\n        resp_auth.raise_for_status()\n        history_auth = resp_auth.json()\n        assert isinstance(history_auth, list), \"Auth user history response should be a list\"\n        assert len(history_auth) >= 1, \"History should contain at least one entry after update\"\n\n        # 3) admin user\n        headers_admin = {\"Authorization\": f\"Bearer {token_admin}\"}\n        resp_admin = requests.get(f\"{BASE_URL}/cases/{case_id}/history\", headers=headers_admin, timeout=TIMEOUT)\n        resp_admin.raise_for_status()\n        history_admin = resp_admin.json()\n        assert isinstance(history_admin, list), \"Admin history response should be a list\"\n        assert len(history_admin) >= 1, \"History should contain at least one entry after update\"\n\n        # Verify Alert and Case Verification features do not interfere (just check public alerts accessible)\n        resp_alerts = requests.get(f\"{BASE_URL}/public/alerts\", timeout=TIMEOUT)\n        resp_alerts.raise_for_status()\n        alerts = resp_alerts.json()\n        assert isinstance(alerts, list), \"Public alerts response should be a list\"\n\n        # Verify public case verification by code (use the code from the case if returned)\n        case_code = None\n        # fetch case details to get code if available\n        resp_case = requests.get(f\"{BASE_URL}/cases/{case_id}\", headers=headers_auth, timeout=TIMEOUT)\n        resp_case.raise_for_status()\n        case_details = resp_case.json()\n        case_code = case_details.get(\"verification_code\") or case_details.get(\"code\")\n        if case_code:\n            resp_verify = requests.get(f\"{BASE_URL}/public/verify/{case_code}\", timeout=TIMEOUT)\n            resp_verify.raise_for_status()\n            verify_data = resp_verify.json()\n            assert isinstance(verify_data, dict), \"Verification response should be a dict\"\n            assert verify_data.get(\"id\") == case_id, \"Verification returned wrong case ID\"\n    finally:\n        if case_id:\n            delete_case(case_id, token_auth)\n\ntest_case_history_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 112, in <module>\n  File \"<string>\", line 52, in test_case_history_retrieval\n  File \"<string>\", line 12, in login\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-30T01:25:23.113Z",
    "modified": "2026-01-30T01:26:11.536Z"
  }
]
